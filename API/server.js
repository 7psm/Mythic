// =============================================
// SERVEUR API PRINCIPAL - MythicMarket
// =============================================
// Ce fichier g√®re l'API backend pour l'e-commerce MythicMarket
// Il traite les commandes et envoie des emails de confirmation

console.log("üöÄ D√©marrage du serveur...");

// Import des modules n√©cessaires
import express from "express";           // Framework web pour Node.js
import cors from "cors";                 // Middleware pour g√©rer les requ√™tes cross-origin
import path from "path";                 // Utilitaire pour manipuler les chemins de fichiers
import fs from "fs";                     // Module syst√®me de fichiers
import { fileURLToPath } from 'url';     // Utilitaire pour obtenir __dirname en modules ES
import emailService from '../MailSystem/emailService-simple.js';  // Service d'envoi d'emails
import { validateConfig } from '../MailSystem/config.js';  // Validation de la configuration
import emailRoutes from '../MailSystem/routes.js';         // Routes d√©di√©es au syst√®me d'email

console.log("‚úÖ Imports r√©ussis");

// Initialisation de l'application Express
const app = express();
const PORT = process.env.PORT || 3001;  // Port depuis les variables d'environnement ou 3001 par d√©faut

// √âquivalent de __dirname pour les modules ES (n√©cessaire pour les imports)
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

console.log(`üìÅ __dirname: ${__dirname}`);

// Validation de la configuration email au d√©marrage du serveur
console.log("üîß Validation de la configuration email...");
const configValidation = validateConfig();
if (configValidation.isValid) {
  console.log("‚úÖ Configuration email valide");
  // Initialisation du service email
  console.log("üîß Initialisation du service email...");
  emailService.initializeTransporter().then(() => {
    console.log("‚úÖ Service email initialis√© avec succ√®s");
  }).catch((error) => {
    console.error("‚ùå Erreur initialisation service email:", error);
  });
} else {
  console.log("‚ùå Configuration email manquante - emails d√©sactiv√©s");
}

// =============================================
// CONFIGURATION DES MIDDLEWARES
// =============================================

// Configuration CORS pour permettre les requ√™tes depuis le frontend
app.use(cors({
  origin: [
    "http://localhost:3001",
    "http://localhost:3000",
    "http://127.0.0.1:5501",  // Live Server local
    "http://127.0.0.1:5500",  // Alternative Live Server port
    "http://localhost:5501",  // Alternative localhost
    "http://localhost:5500",  // Alternative localhost
    "https://mythicmarket.netlify.app",
    "https://mythicmarket.netlify.app/",
    process.env.CORS_ORIGIN
  ].filter(Boolean),  // Filtre les valeurs undefined
  credentials: true,  // Permet l'envoi de cookies et d'en-t√™tes d'authentification
  methods: ['GET', 'POST', 'PUT', 'DELETE', 'OPTIONS'],  // M√©thodes autoris√©es
  allowedHeaders: ['Content-Type', 'Authorization', 'X-Requested-With']  // En-t√™tes autoris√©s
}));

// Middleware pour parser le JSON des requ√™tes
app.use(express.json());

// Middleware pour parser les donn√©es de formulaire
app.use(express.urlencoded({ extended: true }));

// Middleware pour g√©rer les requ√™tes OPTIONS (preflight CORS)
app.options('*', (req, res) => {
  res.header('Access-Control-Allow-Origin', req.headers.origin || '*');
  res.header('Access-Control-Allow-Methods', 'GET, POST, PUT, DELETE, OPTIONS');
  res.header('Access-Control-Allow-Headers', 'Content-Type, Authorization, X-Requested-With');
  res.header('Access-Control-Allow-Credentials', 'true');
  res.sendStatus(200);
});

// =============================================
// ROUTES DE L'API
// =============================================

// Routes d√©di√©es au syst√®me d'email
app.use('/api/email', emailRoutes);

// Route GET pour r√©cup√©rer toutes les commandes
app.get("/api/orders", async (req, res) => {
  try {
    // Chemin vers le fichier JSON des commandes
  const ordersPath = path.join(__dirname, "orders.json");
    
    // Lecture asynchrone du fichier des commandes
    const data = await fs.promises.readFile(ordersPath, "utf8");
    const orders = JSON.parse(data);
    
    // Envoi de la r√©ponse avec toutes les commandes
    res.json(orders);
  } catch (error) {
    console.error("‚ùå Erreur lecture orders.json:", error);
    res.status(500).json({ error: "Impossible de lire orders.json" });
  }
});

// Route POST pour ajouter une nouvelle commande avec envoi d'email automatique
app.post("/api/order", async (req, res) => {
  try {
    // Chemin vers le fichier JSON des commandes
    const ordersPath = path.join(__dirname, "orders.json");
    
    // Lecture des commandes existantes avec gestion d'erreur
    let orders = [];
    try {
      const data = await fs.promises.readFile(ordersPath, "utf8");
      if (data.trim()) { // V√©rifier que le fichier n'est pas vide
        orders = JSON.parse(data);
      }
    } catch (readError) {
      console.log("üìù Initialisation du fichier orders.json");
      orders = []; // Initialiser avec un tableau vide si erreur
    }
    
    // Cr√©ation d'une nouvelle commande avec m√©tadonn√©es
      const newOrder = {
      id: Date.now(),                    // ID unique bas√© sur le timestamp
      ...req.body,                       // Toutes les donn√©es de la commande
      createdAt: new Date().toISOString(), // Date de cr√©ation
      emailSent: false                   // Statut d'envoi d'email initial
    };
    
    // Ajout de la commande √† la liste
      orders.push(newOrder);
      
    // Sauvegarde asynchrone dans le fichier JSON
    await fs.promises.writeFile(ordersPath, JSON.stringify(orders, null, 2));
        console.log("‚úÖ Commande ajout√©e:", newOrder);
    
    // =============================================
    // ENVOI D'EMAIL DE CONFIRMATION (NON-BLOQUANT)
    // =============================================
    
    // V√©rification de la pr√©sence d'un email valide
    const customerEmail = newOrder.email || (newOrder.customerInfo && newOrder.customerInfo.email);
    if (customerEmail && customerEmail !== 'Non renseign√©') {
      // Utilisation de setImmediate pour l'envoi en arri√®re-plan
      setImmediate(async () => {
        try {
          // Tentative d'envoi de l'email de confirmation
          const emailResult = await emailService.sendOrderConfirmation({
            customerEmail: customerEmail,
            customerName: newOrder.customerInfo?.name || newOrder.customerName || 'Client',
            orderNumber: newOrder.orderNumber || newOrder.id,
            totalAmount: newOrder.total || newOrder.totalAmount || 0,
            items: newOrder.cart || newOrder.items || [],
            shippingMethod: newOrder.preferences?.shippingMethod || newOrder.shippingMethod,
            shippingCost: newOrder.shippingCost || 0,
            paymentMethod: newOrder.preferences?.paymentMethod || newOrder.paymentMethod
          });
          
          if (emailResult.success) {
            // Mise √† jour du statut d'envoi si r√©ussi
            newOrder.emailSent = true;
            
            // Mise √† jour du fichier JSON avec le nouveau statut
            const updatedOrders = orders.map(order => 
              order.id === newOrder.id ? { ...order, emailSent: true } : order
            );
            
            await fs.promises.writeFile(ordersPath, JSON.stringify(updatedOrders, null, 2));
            console.log(`‚úÖ Email envoy√© et statut mis √† jour pour la commande ${newOrder.orderNumber}`);
          }
        } catch (emailError) {
          console.error("‚ùå Erreur envoi email:", emailError);
        }
      });
    } else {
      console.log("‚ö†Ô∏è Pas d'email valide pour l'envoi de confirmation");
    }
    
    // R√©ponse imm√©diate au client (sans attendre l'envoi d'email)
    res.status(201).json({ 
      message: "Commande ajout√©e avec succ√®s", 
      order: newOrder, 
      success: true,
      emailStatus: customerEmail && customerEmail !== 'Non renseign√©' ? 'en cours d\'envoi' : 'pas d\'email'
    });
    
  } catch (error) {
    console.error("‚ùå Erreur traitement commande:", error);
    res.status(500).json({ 
      error: "Erreur lors du traitement de la commande", 
      success: false 
    });
  }
});

// =============================================
// ENDPOINT POUR ENVOYER UN EMAIL DE CONFIRMATION
// =============================================
app.post('/api/send-order-email', async (req, res) => {
  try {
    const { customerEmail, customerName, orderNumber, totalAmount, items, shippingMethod, shippingCost, paymentMethod } = req.body;

    // Validation des donn√©es requises
    if (!customerEmail || !customerName || !orderNumber || !totalAmount) {
      return res.status(400).json({
        success: false,
        error: "Donn√©es manquantes pour l'envoi d'email"
      });
    }

    console.log("üìß Demande d'envoi d'email pour la commande:", orderNumber);
    console.log("üë§ Client:", customerName, `(${customerEmail})`);

    // Pr√©paration des donn√©es pour l'email
    const orderData = {
      customerEmail,
      customerName,
      orderNumber,
      totalAmount,
      items: items || [],
      shippingMethod: shippingMethod || "Livraison Standard",
      shippingCost: shippingCost || 0,
      paymentMethod: paymentMethod || "Non sp√©cifi√©"
    };

    // Envoi de l'email via le service
    const emailResult = await emailService.sendOrderConfirmation(orderData);

    if (emailResult.success) {
      console.log("‚úÖ Email envoy√© avec succ√®s pour la commande:", orderNumber);
      res.json({
        success: true,
        message: "Email de confirmation envoy√© avec succ√®s",
        messageId: emailResult.messageId,
        orderNumber
      });
    } else {
      console.error("‚ùå √âchec de l'envoi d'email:", emailResult.error);
      res.status(500).json({
        success: false,
        error: "√âchec de l'envoi de l'email",
        details: emailResult.error
      });
    }

  } catch (error) {
    console.error("‚ùå Erreur lors de l'envoi d'email:", error);
    res.status(500).json({
      success: false,
      error: "Erreur interne du serveur lors de l'envoi d'email"
    });
  }
});



// ========================================
// SYST√àME DE MAINTENANCE S√âCURIS√â
// ========================================

// Emplacement du fichier de persistance
const maintenanceDataPath = path.join(__dirname, 'maintenance.json');

// Valeurs par d√©faut
let maintenanceStatus = { status: 'online', timestamp: new Date().toISOString(), lastUpdatedBy: 'system' };
let maintenanceUpdates = { text: 'Aucune mise √† jour pour le moment.', enabled: false, timestamp: new Date().toISOString(), lastUpdatedBy: 'system' };

// Charger les donn√©es persist√©es au d√©marrage
try {
  if (fs.existsSync(maintenanceDataPath)) {
    const raw = fs.readFileSync(maintenanceDataPath, 'utf8');
    if (raw.trim()) {
      const parsed = JSON.parse(raw);
      if (parsed.status) maintenanceStatus = parsed.status;
      if (parsed.updates) maintenanceUpdates = parsed.updates;
      console.log('üíæ Donn√©es maintenance charg√©es depuis le disque');
    }
  }
} catch (e) {
  console.warn('‚ö†Ô∏è Impossible de charger maintenance.json:', e.message);
}

function saveMaintenanceData() {
  try {
    const data = { status: maintenanceStatus, updates: maintenanceUpdates };
    fs.writeFileSync(maintenanceDataPath, JSON.stringify(data, null, 2));
    console.log('üíæ Donn√©es maintenance sauvegard√©es');
  } catch (e) {
    console.error('‚ùå Erreur sauvegarde maintenance.json:', e.message);
  }
}

// Endpoint pour r√©cup√©rer le statut de maintenance (public)
app.get('/api/maintenance/status', (req, res) => {
  res.json({
    status: maintenanceStatus.status,
    timestamp: maintenanceStatus.timestamp,
    lastUpdatedBy: maintenanceStatus.lastUpdatedBy
  });
});

// Endpoint pour mettre √† jour le statut de maintenance (s√©curis√©)
app.post('/api/maintenance/update', (req, res) => {
  const { status } = req.body;
  
  // Pour le d√©veloppement local, on accepte toutes les requ√™tes
  // En production, vous devriez ajouter une authentification
  
  // Validation du statut
  const validStatuses = ['online', 'maintenance', 'offline', 'critical'];
  if (!validStatuses.includes(status)) {
    return res.status(400).json({ 
      error: 'Statut invalide',
      message: 'Les statuts valides sont: online, maintenance, offline, critical'
    });
  }
  
  try {
    // Mise √† jour du statut
    maintenanceStatus = {
      status: status,
      timestamp: new Date().toISOString(),
      lastUpdatedBy: 'admin'
    };
    
    console.log(`üîß Statut de maintenance mis √† jour: ${status}`);
    saveMaintenanceData();
    
    res.json({
      success: true,
      message: `Statut mis √† jour: ${status}`,
      data: maintenanceStatus
    });
    
  } catch (error) {
    console.error('‚ùå Erreur lors de la mise √† jour du statut:', error);
    res.status(500).json({ 
      error: 'Erreur serveur',
      message: 'Impossible de mettre √† jour le statut'
    });
  }
});

// Endpoint pour r√©initialiser le statut (s√©curis√©)
app.post('/api/maintenance/reset', (req, res) => {
  // Pour le d√©veloppement local, on accepte toutes les requ√™tes
  // En production, vous devriez ajouter une authentification
  
  try {
    maintenanceStatus = {
      status: 'online',
      timestamp: new Date().toISOString(),
      lastUpdatedBy: 'admin'
    };
    
    console.log('üîÑ Statut de maintenance r√©initialis√©');
    saveMaintenanceData();
    
    res.json({
      success: true,
      message: 'Statut r√©initialis√© √† "online"',
      data: maintenanceStatus
    });
    
  } catch (error) {
    console.error('‚ùå Erreur lors de la r√©initialisation:', error);
    res.status(500).json({ 
      error: 'Erreur serveur',
      message: 'Impossible de r√©initialiser le statut'
    });
  }
});

// ========================================
// MISES √Ä JOUR (CHANGELOG/NOTES)
// ========================================

// R√©cup√©rer les mises √† jour
app.get('/api/maintenance/updates', (req, res) => {
  res.json({
    success: true,
    updates: maintenanceUpdates
  });
});

// Mettre √† jour le texte des mises √† jour
app.post('/api/maintenance/updates', (req, res) => {
  const { text, enabled } = req.body || {};
  try {
    maintenanceUpdates = {
      text: typeof text === 'string' && text.trim() ? text : maintenanceUpdates.text,
      enabled: typeof enabled === 'boolean' ? enabled : maintenanceUpdates.enabled,
      timestamp: new Date().toISOString(),
      lastUpdatedBy: 'admin'
    };
    console.log('üìù Notes de mise √† jour modifi√©es');
    saveMaintenanceData();
    res.json({ success: true, updates: maintenanceUpdates });
  } catch (error) {
    console.error('‚ùå Erreur MAJ notes:', error);
    res.status(500).json({ success: false, error: 'Impossible de mettre √† jour les notes' });
  }
});

// Activer/d√©sactiver l'affichage des mises √† jour
app.post('/api/maintenance/updates/toggle', (req, res) => {
  const { enabled } = req.body || {};
  try {
    if (typeof enabled !== 'boolean') {
      return res.status(400).json({ success: false, error: 'Param√®tre enabled invalide' });
    }
    maintenanceUpdates.enabled = enabled;
    maintenanceUpdates.timestamp = new Date().toISOString();
    maintenanceUpdates.lastUpdatedBy = 'admin';
    console.log(`üîî Affichage mises √† jour: ${enabled ? 'activ√©' : 'd√©sactiv√©'}`);
    saveMaintenanceData();
    res.json({ success: true, updates: maintenanceUpdates });
  } catch (error) {
    console.error('‚ùå Erreur toggle updates:', error);
    res.status(500).json({ success: false, error: 'Impossible de changer l\'√©tat des mises √† jour' });
  }
});

// =============================================
// SERVIR LE FRONTEND
// =============================================

// Configuration pour servir les fichiers statiques (HTML, CSS, JS, images)
app.use(express.static(path.join(__dirname, "../")));

// Route catch-all pour le routage c√¥t√© client (DOIT √™tre en dernier)
app.get("*", (req, res) => {
  const indexPath = path.join(__dirname, "../index.html");
  res.sendFile(indexPath, (err) => {
    if (err) {
      // Lorsqu'un client ferme la connexion (rafra√Æchissement/fermeture d'onglet),
      // Express peut remonter une erreur ECONNABORTED/ECONNRESET. On l'ignore.
      if (err.code === 'ECONNABORTED' || err.code === 'ECONNRESET') {
        console.warn("‚ö†Ô∏è  Requ√™te client interrompue pendant l'envoi de index.html (ignor√©e)");
        return;
      }
      console.error("Erreur envoi index.html:", err);
      if (!res.headersSent) {
        res.status(500).send("Erreur serveur");
      }
    }
  });
});

// ========================================
// D√âMARRAGE DU SERVEUR
// ========================================

// D√©marrage du serveur sur le port configur√©
app.listen(PORT, () => {
  console.log(`üöÄ Server running on port ${PORT}`);
  console.log(`üìÅ Serving files from: ${path.join(__dirname, "../")}`);
  console.log(`üõ†Ô∏è  API available at: http://localhost:${PORT}/api/orders`);
  console.log(`üåê Website available at: http://localhost:${PORT}/`);
});

// =============================================
// GESTION DES ERREURS NON CAPTUR√âES
// =============================================

// Gestion des promesses rejet√©es non g√©r√©es
process.on('unhandledRejection', (reason, promise) => {
  console.error('Unhandled Rejection at:', promise, 'reason:', reason);
});

// Gestion des exceptions non captur√©es
process.on('uncaughtException', (err) => {
  console.error('Uncaught Exception:', err);
  process.exit(1);  // Arr√™t du processus en cas d'erreur critique
});